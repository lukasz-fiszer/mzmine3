/*
 * Copyright 2006-2020 The MZmine Development Team
 *
 * This file is part of MZmine.
 *
 * MZmine is free software; you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * MZmine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with MZmine; if not,
 * write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
 * USA
 */

package io.github.mzmine.modules.visualization.productionfilter;

import com.google.common.collect.Range;
import io.github.mzmine.datamodel.RawDataFile;
import io.github.mzmine.datamodel.data.ModularFeatureList;
import io.github.mzmine.gui.mainwindow.MZmineTab;
import io.github.mzmine.main.MZmineCore;
import io.github.mzmine.parameters.ParameterSet;
import io.github.mzmine.parameters.parametertypes.WindowSettingsParameter;
import io.github.mzmine.parameters.parametertypes.tolerances.MZTolerance;
import io.github.mzmine.taskcontrol.TaskPriority;
import io.github.mzmine.util.javafx.FxIconUtil;
import io.github.mzmine.util.javafx.WindowsMenu;
import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import javafx.geometry.Orientation;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ToolBar;
import javafx.scene.control.Tooltip;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import javax.annotation.Nonnull;

/**
 * Product Ion Filter generated by Shawn Hoogstra : shoogstr@uwo.ca
 */
public class ProductIonFilterVisualizerTab extends MZmineTab {

  private static final Image PRECURSOR_MASS_ICON =
      FxIconUtil.loadImageFromResources("icons/datapointsicon.png");
  private ToolBar toolBar;
  private ProductIonFilterPlot productIonFilterPlot;
  private BorderPane borderPane;
  private Scene scene;
  private ProductIonFilterDataSet dataset;
  private RawDataFile dataFile;

  // For m/z tolerance for previous filters
  private MZTolerance mzDifference;
  private List<Double> targetedMZ_List;
  private List<Double> targetedNF_List;
  private File fileName;
  private double basePeakPercent;
  private Range<Double> rtRange;
  private Range<Double> mzRange;
  private Object xAxisType;


  public ProductIonFilterVisualizerTab(RawDataFile dataFile, ParameterSet parameters) {
    super("Product Ion Filter Visualizer", true ,false);
    borderPane = new BorderPane();
    //scene = new Scene(borderPane);
    //setScene(scene);

    this.dataFile = dataFile;

    // Retrieve parameter's values
    rtRange = parameters.getParameter(ProductIonFilterParameters.retentionTimeRange).getValue();
    mzRange = parameters.getParameter(ProductIonFilterParameters.mzRange).getValue();
    xAxisType = parameters.getParameter(ProductIonFilterParameters.xAxisType).getValue();

    mzDifference = parameters.getParameter(ProductIonFilterParameters.mzDifference).getValue();

    targetedMZ_List =
        parameters.getParameter(ProductIonFilterParameters.targetedMZ_List).getValue();
    targetedNF_List =
        parameters.getParameter(ProductIonFilterParameters.targetedNF_List).getValue();

    fileName = parameters.getParameter(ProductIonFilterParameters.fileName).getValue();

    basePeakPercent =
        parameters.getParameter(ProductIonFilterParameters.basePeakPercent).getValue();

    // Set window components
    dataset = new ProductIonFilterDataSet(dataFile, xAxisType, rtRange, mzRange, this, mzDifference,
        targetedMZ_List, targetedNF_List, basePeakPercent, fileName);

    productIonFilterPlot = new ProductIonFilterPlot(this);
    productIonFilterPlot.setAxisTypes(xAxisType);
    productIonFilterPlot.addProductionFilterDataSet(dataset);
    productIonFilterPlot.setMenuItems();
    borderPane.setCenter(productIonFilterPlot);

    toolBar = new ToolBar();
    toolBar.setOrientation(Orientation.VERTICAL);
    Button highlightPrecursorBtn = new Button(null, new ImageView(PRECURSOR_MASS_ICON));
    highlightPrecursorBtn.setTooltip(new Tooltip("Highlight selected precursor mass range"));
    highlightPrecursorBtn.setOnAction(e -> {
      ProductIonFilterSetHighlightDialog dialog =
          new ProductIonFilterSetHighlightDialog(MZmineCore.getDesktop().getMainWindow(), productIonFilterPlot, "HIGHLIGHT_PRECURSOR");
      dialog.show();
    });
    toolBar.getItems().add(highlightPrecursorBtn);
    borderPane.setRight(toolBar);

    MZmineCore.getTaskController().addTask(dataset, TaskPriority.HIGH);

    updateTitle();

    // Add the Windows menu
    //WindowsMenu.addWindowsMenu(getScene());

    // get the window settings parameter
    //ParameterSet paramSet =
    //    MZmineCore.getConfiguration().getModuleParameters(ProductIonFilterVisualizerModule.class);
    //WindowSettingsParameter settings =
    //    paramSet.getParameter(ProductIonFilterParameters.windowSettings);

    // update the window and listen for changes
    //settings.applySettingsToWindow(this);
    setContent(borderPane);
  }

  void updateTitle() {

    StringBuilder title = new StringBuilder();
    title.append("[");
    title.append(dataFile.getName());
    title.append("]: fragment filter");

    //setTitle(title.toString());
    productIonFilterPlot.setTitle(title.toString());

    ProductIonFilterDataPoint pos = getCursorPosition();

    if (pos != null) {
      title.append(", ");
      title.append(pos.getName());
    }

    productIonFilterPlot.setTitle(title.toString());

  }


  public ProductIonFilterDataPoint getCursorPosition() {
    double xValue = productIonFilterPlot.getXYPlot().getDomainCrosshairValue();
    double yValue = productIonFilterPlot.getXYPlot().getRangeCrosshairValue();

    ProductIonFilterDataPoint point = dataset.getDataPoint(xValue, yValue);
    return point;

  }

  ProductIonFilterPlot getPlot() {
    return productIonFilterPlot;
  }

  public RawDataFile getDataFile() {
    return this.dataFile;
  }

  @Nonnull
  @Override
  public Collection<? extends RawDataFile> getRawDataFiles() {
    return new ArrayList<>(Collections.singletonList(dataFile));
  }

  @Nonnull
  @Override
  public Collection<? extends ModularFeatureList> getFeatureLists() {
    return Collections.emptyList();
  }

  @Nonnull
  @Override
  public Collection<? extends ModularFeatureList> getAlignedFeatureLists() {
    return Collections.emptyList();
  }

  @Override
  public void onRawDataFileSelectionChanged(Collection<? extends RawDataFile> rawDataFiles) {
    if(rawDataFiles == null || rawDataFiles.isEmpty()) {
      return;
    }

    // get first raw data file
    RawDataFile newFile = rawDataFiles.iterator().next();
    if (dataFile.equals(newFile)) {
      return;
    }

    // remove old dataset
    productIonFilterPlot.getXYPlot().setDataset(
        productIonFilterPlot.getXYPlot().indexOf(dataset),null);

    // add new dataset
    ProductIonFilterDataSet newDataset = new ProductIonFilterDataSet(newFile, xAxisType, rtRange, mzRange, this, mzDifference,
        targetedMZ_List, targetedNF_List, basePeakPercent, fileName);
    productIonFilterPlot.addProductionFilterDataSet(newDataset);

    dataFile = newFile;
    dataset = newDataset;

    MZmineCore.getTaskController().addTask(newDataset, TaskPriority.HIGH);
    updateTitle();
  }

  @Override
  public void onFeatureListSelectionChanged(Collection<? extends ModularFeatureList> featureLists) {

  }

  @Override
  public void onAlignedFeatureListSelectionChanged(
      Collection<? extends ModularFeatureList> featurelists) {

  }
}
